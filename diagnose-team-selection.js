// Diagnostic script to test Blue vs Red genome selection// Test the specific scenario where Blue team gets different treatmentconst mockCandidatePool = [    {        genome: [0.8, 0.6, 0.7, 0.5, 0.9, 0.4, 0.6, 0.7, 0.5], // High aggression (0.8)        fitness: 0.85,        team: 'red',        battles: 6,        wins: 4,        id: 'red_1'    },    {        genome: [0.4, 0.8, 0.9, 0.7, 0.6, 0.8, 0.5, 0.3, 0.7], // Low aggression (0.4), high teamwork (0.6)        fitness: 0.78,        team: 'blue',         battles: 6,        wins: 3,        id: 'blue_1'    }];mockCandidatePool.forEach((candidate, i) => {    const genome = candidate.genome;});// Test trait-based selection logicfunction testTraitSelection(team, candidates) {    for (const candidate of candidates) {        const genome = candidate.genome;        const aggression = genome[0] || 0;        const teamwork = genome[4] || 0;        const defense = genome[3] || 0;        // Apply the selection logic from the main code        if (team === 'red' && aggression > 0.3) {            return candidate;        } else if (team === 'blue' && (teamwork > 0.3 || defense > 0.3)) {            return candidate;        } else {        }    }    return null;}const redSelection = testTraitSelection('red', mockCandidatePool);const blueSelection = testTraitSelection('blue', mockCandidatePool);` : 'none');` : 'none');// Test fallback logic// Sort by fitness (as the code does)const sortedCandidates = [...mockCandidatePool].sort((a, b) => (b.fitness || 0) - (a.fitness || 0));sortedCandidates.forEach((c, i) => {});if (sortedCandidates.length > 0) {');    if (sortedCandidates.length > 1) {');    } else {    }}