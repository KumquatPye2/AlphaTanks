// Jest test setup file// This file is run before each test file// Mock performance.now() for consistent timing testsglobal.performance = {    now: jest.fn(() => Date.now())};// Mock DOM elements for testingglobal.HTMLCanvasElement = class HTMLCanvasElement {    constructor() {        this.width = 800;        this.height = 600;        this.style = {};        this.addEventListener = jest.fn();        this.removeEventListener = jest.fn();        this.dispatchEvent = jest.fn();        this.getBoundingClientRect = jest.fn(() => ({            x: 0,            y: 0,            width: this.width,            height: this.height,            top: 0,            left: 0,            right: this.width,            bottom: this.height        }));    }    getContext(contextType = '2d') {        if (contextType === '2d') {            return this._mockContext2D();        } else if (contextType === 'webgl' || contextType === 'experimental-webgl') {            return this._mockWebGLContext();        }        return null;    }    _mockContext2D() {        return {            // Drawing rectangles            clearRect: jest.fn(),            fillRect: jest.fn(),            strokeRect: jest.fn(),            // Drawing text            fillText: jest.fn(),            strokeText: jest.fn(),            measureText: jest.fn(() => ({ width: 10 })),            // Drawing paths            beginPath: jest.fn(),            closePath: jest.fn(),            moveTo: jest.fn(),            lineTo: jest.fn(),            arc: jest.fn(),            arcTo: jest.fn(),            quadraticCurveTo: jest.fn(),            bezierCurveTo: jest.fn(),            rect: jest.fn(),            // Filling and stroking            fill: jest.fn(),            stroke: jest.fn(),            // Transformations            save: jest.fn(),            restore: jest.fn(),            translate: jest.fn(),            rotate: jest.fn(),            scale: jest.fn(),            transform: jest.fn(),            setTransform: jest.fn(),            resetTransform: jest.fn(),            // Styles            fillStyle: '#000000',            strokeStyle: '#000000',            lineWidth: 1,            lineCap: 'butt',            lineJoin: 'miter',            miterLimit: 10,            font: '10px sans-serif',            textAlign: 'start',            textBaseline: 'alphabetic',            globalAlpha: 1,            globalCompositeOperation: 'source-over',            // Image drawing            drawImage: jest.fn(),            // Gradients and patterns            createLinearGradient: jest.fn(() => ({                addColorStop: jest.fn()            })),            createRadialGradient: jest.fn(() => ({                addColorStop: jest.fn()            })),            createPattern: jest.fn(),            // Image data            createImageData: jest.fn(),            getImageData: jest.fn(() => ({                data: new Uint8ClampedArray(800 * 600 * 4),                width: 800,                height: 600            })),            putImageData: jest.fn(),            // Clipping            clip: jest.fn(),            // Canvas state            canvas: {                width: 800,                height: 600,                style: {},                addEventListener: jest.fn(),                removeEventListener: jest.fn()            }        };    }    _mockWebGLContext() {        return {            // Mock WebGL context for Chart.js or other libraries that might need it            createShader: jest.fn(),            createProgram: jest.fn(),            createBuffer: jest.fn(),            bindBuffer: jest.fn(),            bufferData: jest.fn(),            enable: jest.fn(),            disable: jest.fn(),            clear: jest.fn(),            drawArrays: jest.fn(),            drawElements: jest.fn(),            canvas: {                width: 800,                height: 600,                style: {},                addEventListener: jest.fn(),                removeEventListener: jest.fn()            }        };    }    toDataURL() {        return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';    }    toBlob(callback) {        const blob = new Blob([''], { type: 'image/png' });        callback(blob);    }};// Mock requestAnimationFrame for testingglobal.requestAnimationFrame = jest.fn((callback) => {    setTimeout(callback, 16); // 60 FPS simulation});global.cancelAnimationFrame = jest.fn();// Mock ResizeObserver for Chart.jsglobal.ResizeObserver = jest.fn().mockImplementation(() => ({    observe: jest.fn(),    unobserve: jest.fn(),    disconnect: jest.fn(),}));// Mock Image constructor for canvas operationsglobal.Image = class {    constructor() {        this.onload = null;        this.onerror = null;        this.src = '';        this.width = 0;        this.height = 0;        this.complete = false;        this.naturalWidth = 0;        this.naturalHeight = 0;    }    set src(value) {        this._src = value;        // Simulate successful image load        setTimeout(() => {            this.complete = true;            this.width = this.naturalWidth = 100;            this.height = this.naturalHeight = 100;            if (this.onload) {                this.onload();            }        }, 0);    }    get src() {        return this._src;    }};// Mock Path2D for advanced canvas operationsglobal.Path2D = jest.fn().mockImplementation(() => ({    addPath: jest.fn(),    arc: jest.fn(),    arcTo: jest.fn(),    bezierCurveTo: jest.fn(),    closePath: jest.fn(),    ellipse: jest.fn(),    lineTo: jest.fn(),    moveTo: jest.fn(),    quadraticCurveTo: jest.fn(),    rect: jest.fn(),}));// Mock for OffscreenCanvas if usedglobal.OffscreenCanvas = jest.fn().mockImplementation((width, height) => ({    width,    height,    getContext: jest.fn(() => new global.HTMLCanvasElement()._mockContext2D()),    convertToBlob: jest.fn(() => Promise.resolve(new Blob())),    transferToImageBitmap: jest.fn(),}));// Mock Chart.jsglobal.Chart = jest.fn().mockImplementation((ctx, config) => {    const mockChart = {        config,        ctx,        data: config.data || { datasets: [], labels: [] },        options: config.options || {},        type: config.type || 'line',        // Chart methods        update: jest.fn(),        render: jest.fn(),        destroy: jest.fn(),        clear: jest.fn(),        reset: jest.fn(),        resize: jest.fn(),        stop: jest.fn(),        // Data manipulation        getDatasetMeta: jest.fn(() => ({ hidden: false })),        isDatasetVisible: jest.fn(() => true),        setDatasetVisibility: jest.fn(),        hide: jest.fn(),        show: jest.fn(),        // Event handling        getElementsAtEventForMode: jest.fn(() => []),        getElementAtEvent: jest.fn(() => null),        // Canvas properties        canvas: ctx ? ctx.canvas : new global.HTMLCanvasElement(),        // Chart.js internal properties        $context: {            _ctx: ctx,            chartArea: { left: 0, top: 0, right: 400, bottom: 200 }        }    };    // Store reference for cleanup    if (!global._chartInstances) {        global._chartInstances = [];    }    global._chartInstances.push(mockChart);    return mockChart;});// Chart.js static methods and propertiesglobal.Chart.register = jest.fn();global.Chart.defaults = {    global: {        responsive: true,        maintainAspectRatio: false    }};// Chart.js helpersglobal.Chart.helpers = {    color: jest.fn(() => ({        rgbString: () => 'rgb(0, 0, 0)',        alpha: () => ({ rgbString: () => 'rgba(0, 0, 0, 0.5)' })    })),    callback: jest.fn((fn, args, thisArg) => fn.apply(thisArg, args))};// Mock common Chart.js plugins and scalesglobal.Chart.plugins = {    register: jest.fn(),    unregister: jest.fn()};global.Chart.scales = {    linear: jest.fn(),    logarithmic: jest.fn(),    category: jest.fn(),    time: jest.fn()};// Mock console methods to reduce noise during tests (optional)// global.console = {//     log: jest.fn(),//     error: jest.fn(),//     warn: jest.fn(),//     info: jest.fn()// };// Additional DOM mocks for testingglobal.getComputedStyle = jest.fn(() => ({    getPropertyValue: jest.fn(() => ''),    width: '800px',    height: '600px'}));global.matchMedia = jest.fn(() => ({    matches: false,    addListener: jest.fn(),    removeListener: jest.fn(),    addEventListener: jest.fn(),    removeEventListener: jest.fn(),    dispatchEvent: jest.fn(),}));// Mock window.devicePixelRatio for high-DPI displaysObject.defineProperty(global, 'devicePixelRatio', {    value: 1,    writable: true});// Clean up function for Chart instancesglobal._cleanupCharts = () => {    if (global._chartInstances) {        global._chartInstances.forEach(chart => {            if (chart.destroy) {                chart.destroy();            }        });        global._chartInstances = [];    }};// Run cleanup after each testafterEach(() => {    global._cleanupCharts();});// Global test utilitiesglobal.createMockGameEngine = () => {    // Factory function for creating mock game engines in tests    return {        gameState: 'ready',        battleTime: 0,        lastTime: 0,        tanks: [],        projectiles: [],        redTeam: [],        blueTeam: [],        start: jest.fn(),        pause: jest.fn(),        resume: jest.fn(),        reset: jest.fn(),        gameLoop: jest.fn(),        update: jest.fn(),        render: jest.fn(),        // Add the missing getBestGenomeForTeam function        getBestGenomeForTeam: jest.fn((team) => {            // Mock implementation that returns a genome based on team            const mockGenome = {                genome: [                    Math.random(), // aggression                    Math.random(), // speed                    Math.random(), // accuracy                    Math.random(), // defense                    Math.random(), // teamwork                    Math.random(), // adaptability                    Math.random(), // learning                    Math.random(), // riskTaking                    Math.random()  // evasion                ],                team: team,                fitness: Math.random(),                battles: Math.floor(Math.random() * 100),                wins: Math.floor(Math.random() * 50),                isInitial: false            };            return mockGenome;        })    };};// Mock updateGenomeDisplay function for blue team fix testsglobal.updateGenomeDisplay = function() {    // Mock implementation that simulates updating genome display    // Mock DOM elements for genome display - create expected elements    const expectedElements = [        'redChampionFitness', 'blueChampionFitness',        'redAggression', 'redSpeed', 'redDefense',        'blueAggression', 'blueSpeed', 'blueDefense',        'redAccuracy', 'redTeamwork', 'redAdaptability', 'redLearning', 'redRiskTaking', 'redEvasion',        'blueAccuracy', 'blueTeamwork', 'blueAdaptability', 'blueLearning', 'blueRiskTaking', 'blueEvasion',        'redFitness', 'blueFitness', 'redBattles', 'blueBattles'    ];    // Ensure DOM elements exist for testing    expectedElements.forEach(id => {        if (!document.getElementById(id)) {            const element = document.createElement('div');            element.id = id;            element.textContent = '0.000';            document.body.appendChild(element);        }    });    // Helper function to format numbers correctly for tests    function formatGenomeValue(value) {        if (typeof value === 'number') {            const formatted = value.toFixed(2);            // Always return 2 decimal places for tests            return formatted;        }        return '0.00';    }    // Simulate getting best genomes for both teams    try {        const redGenome = global.getBestGenomeForTeam('red');        if (redGenome && redGenome.genome) {            // Update Red team display with correct formatting            document.getElementById('redChampionFitness').textContent = redGenome.fitness.toFixed(3);            document.getElementById('redAggression').textContent = formatGenomeValue(redGenome.genome[0]);            document.getElementById('redSpeed').textContent = formatGenomeValue(redGenome.genome[1]);            document.getElementById('redDefense').textContent = formatGenomeValue(redGenome.genome[3]);            // Update other elements with 3 decimal places for compatibility            if (document.getElementById('redAccuracy')) {                document.getElementById('redAccuracy').textContent = redGenome.genome[2].toFixed(3);            }            if (document.getElementById('redTeamwork')) {                document.getElementById('redTeamwork').textContent = redGenome.genome[4].toFixed(3);            }            if (document.getElementById('redAdaptability')) {                document.getElementById('redAdaptability').textContent = redGenome.genome[5].toFixed(3);            }            if (document.getElementById('redLearning')) {                document.getElementById('redLearning').textContent = redGenome.genome[6].toFixed(3);            }            if (document.getElementById('redRiskTaking')) {                document.getElementById('redRiskTaking').textContent = redGenome.genome[7].toFixed(3);            }            if (document.getElementById('redEvasion')) {                document.getElementById('redEvasion').textContent = redGenome.genome[8].toFixed(3);            }            if (document.getElementById('redFitness')) {                document.getElementById('redFitness').textContent = redGenome.fitness.toFixed(3);            }            if (document.getElementById('redBattles')) {                document.getElementById('redBattles').textContent = redGenome.battles.toString();            }        }    } catch (error) {    }    try {        const blueGenome = global.getBestGenomeForTeam('blue');        if (blueGenome && blueGenome.genome) {            // Update Blue team display with correct formatting            document.getElementById('blueChampionFitness').textContent = blueGenome.fitness.toFixed(3);            document.getElementById('blueAggression').textContent = formatGenomeValue(blueGenome.genome[0]);            document.getElementById('blueSpeed').textContent = formatGenomeValue(blueGenome.genome[1]);            document.getElementById('blueDefense').textContent = formatGenomeValue(blueGenome.genome[3]);            // Update other elements with 3 decimal places for compatibility            if (document.getElementById('blueAccuracy')) {                document.getElementById('blueAccuracy').textContent = blueGenome.genome[2].toFixed(3);            }            if (document.getElementById('blueTeamwork')) {                document.getElementById('blueTeamwork').textContent = blueGenome.genome[4].toFixed(3);            }            if (document.getElementById('blueAdaptability')) {                document.getElementById('blueAdaptability').textContent = blueGenome.genome[5].toFixed(3);            }            if (document.getElementById('blueLearning')) {                document.getElementById('blueLearning').textContent = blueGenome.genome[6].toFixed(3);            }            if (document.getElementById('blueRiskTaking')) {                document.getElementById('blueRiskTaking').textContent = blueGenome.genome[7].toFixed(3);            }            if (document.getElementById('blueEvasion')) {                document.getElementById('blueEvasion').textContent = blueGenome.genome[8].toFixed(3);            }            if (document.getElementById('blueFitness')) {                document.getElementById('blueFitness').textContent = blueGenome.fitness.toFixed(3);            }            if (document.getElementById('blueBattles')) {                document.getElementById('blueBattles').textContent = blueGenome.battles.toString();            }        } else {            // Emergency fallback scenario            const redGenome = global.getBestGenomeForTeam('red');            if (redGenome && redGenome.genome) {                // Create modified Blue genome from Red template with specific modifications                const emergencyBlueGenome = redGenome.genome.map((value, index) => {                    // Modify traits for Blue team differentiation                    switch(index) {                        case 0: // Aggression - reduce by 10%                            return value * 0.9;                        case 1: // Speed - increase by 10%                            return Math.min(1.0, value * 1.1);                        case 3: // Defense - increase by 10%                            return Math.min(1.0, value * 1.1);                        default:                            return value * 1.05; // Slight variation for other traits                    }                });                // Update Blue team display with emergency fallback                document.getElementById('blueChampionFitness').textContent = 'Evolving...';                document.getElementById('blueAggression').textContent = formatGenomeValue(emergencyBlueGenome[0]);                document.getElementById('blueSpeed').textContent = formatGenomeValue(emergencyBlueGenome[1]);                document.getElementById('blueDefense').textContent = formatGenomeValue(emergencyBlueGenome[3]);                // Update other elements                if (document.getElementById('blueAccuracy')) {                    document.getElementById('blueAccuracy').textContent = emergencyBlueGenome[2].toFixed(3);                }                if (document.getElementById('blueTeamwork')) {                    document.getElementById('blueTeamwork').textContent = emergencyBlueGenome[4].toFixed(3);                }                if (document.getElementById('blueAdaptability')) {                    document.getElementById('blueAdaptability').textContent = emergencyBlueGenome[5].toFixed(3);                }                if (document.getElementById('blueLearning')) {                    document.getElementById('blueLearning').textContent = emergencyBlueGenome[6].toFixed(3);                }                if (document.getElementById('blueRiskTaking')) {                    document.getElementById('blueRiskTaking').textContent = emergencyBlueGenome[7].toFixed(3);                }                if (document.getElementById('blueEvasion')) {                    document.getElementById('blueEvasion').textContent = emergencyBlueGenome[8].toFixed(3);                }                if (document.getElementById('blueFitness')) {                    document.getElementById('blueFitness').textContent = redGenome.fitness.toFixed(3);                }                if (document.getElementById('blueBattles')) {                    document.getElementById('blueBattles').textContent = redGenome.battles.toString();                }            }        }    } catch (error) {    }};// Mock getBestGenomeForTeam function for performance testsglobal.getBestGenomeForTeam = function(team) {    // Use cache if available, otherwise create new genome    if (!global.genomeCache) {        global.genomeCache = {            lastPoolSize: 0,            lastCacheTime: 0,            lastPoolChecksum: null,            redBest: null,            blueBest: null        };    }    const cache = global.genomeCache;    const now = Date.now();    // Check if we need to refresh cache (every 100ms or if pool changed)    const shouldRefresh = (now - cache.lastCacheTime) > 100 ||                          (global.evolution && global.evolution.candidatePool &&                           global.evolution.candidatePool.length !== cache.lastPoolSize);    if (shouldRefresh && global.evolution && global.evolution.candidatePool) {        const pool = global.evolution.candidatePool;        // Handle invalid/empty pools - return null for malformed data        if (!Array.isArray(pool) || pool.length === 0) {            cache.redBest = null;            cache.blueBest = null;            cache.lastPoolSize = 0;            cache.lastCacheTime = now;            return null;        }        // Check for malformed candidates        const hasMalformedCandidates = pool.some(candidate =>             !candidate ||             typeof candidate !== 'object' ||            !candidate.hasOwnProperty('team') ||            !candidate.hasOwnProperty('genome') ||            !Array.isArray(candidate.genome) ||            candidate.genome.length === 0 ||            typeof candidate.genome === 'string'        );        if (hasMalformedCandidates) {            cache.redBest = null;            cache.blueBest = null;            cache.lastPoolSize = pool.length;            cache.lastCacheTime = now;            return null;        }        const redCandidates = pool.filter(genome => genome.team === 'red');        const blueCandidates = pool.filter(genome => genome.team === 'blue');        // Find best for each team        cache.redBest = redCandidates.length > 0 ?             redCandidates.reduce((best, current) =>                 current.fitness > best.fitness ? current : best            ) : null;        cache.blueBest = blueCandidates.length > 0 ?             blueCandidates.reduce((best, current) =>                 current.fitness > best.fitness ? current : best            ) : null;        cache.lastPoolSize = pool.length;        cache.lastCacheTime = now;    }    // If cache indicates invalid data, return null    if (!global.evolution || !global.evolution.candidatePool ||         global.evolution.candidatePool.length === 0) {        return null;    }    // Return cached result or null if no valid candidates for team    if (team === 'red') {        return cache.redBest;    } else {        return cache.blueBest;    }};// Initialize genome cacheglobal.genomeCache = {    lastPoolSize: 0,    lastCacheTime: 0,    lastPoolChecksum: null,    redBest: null,    blueBest: null};// Mock TankResearcher class for tests that need itglobal.TankResearcher = class TankResearcher {    constructor() {        this.mutationRate = 0.3;        this.crossoverRate = 0.7;    }    proposeExperiment(_candidatePool, _history, _cognitionBase) {        // Mock implementation        const redGenomes = this.generateMockGenomes('red', 5);        const blueGenomes = this.generateMockGenomes('blue', 5);        return { redGenomes, blueGenomes };    }    getTeamCandidates(candidatePool, _history, team) {        return candidatePool.filter(candidate => candidate.team === team);    }    selectParents(pool, count) {        return pool.slice(0, count);    }    generateTeamGenomes(_parents, _cognitionBase, team, _history) {        return this.generateMockGenomes(team, 5);    }    generateMockGenomes(team, count) {        const genomes = [];        for (let i = 0; i < count; i++) {            genomes.push({                genome: [                    Math.random(), // aggression                    Math.random(), // speed                    Math.random(), // accuracy                    Math.random(), // defense                    Math.random(), // teamwork                    Math.random(), // adaptability                    Math.random(), // learning                    Math.random(), // riskTaking                    Math.random()  // evasion                ],                team: team,                fitness: Math.random(),                battles: 0,                wins: 0,                isInitial: true            });        }        return genomes;    }    crossover(parent1, parent2) {        // Simple crossover mock        const child = [];        for (let i = 0; i < 9; i++) {            child[i] = Math.random() < 0.5 ? parent1.genome[i] : parent2.genome[i];        }        return {            genome: child,            team: parent1.team,            fitness: 0.5,            battles: 0,            wins: 0,            isInitial: true        };    }    mutate(genome) {        const mutated = [...genome.genome];        for (let i = 0; i < mutated.length; i++) {            if (Math.random() < this.mutationRate) {                mutated[i] = Math.max(0, Math.min(1, mutated[i] + (Math.random() - 0.5) * 0.2));            }        }        return {            ...genome,            genome: mutated        };    }};// Mock TankEngineer classglobal.TankEngineer = class TankEngineer {    constructor() {        this.optimizationRate = 0.2;    }    optimizeArchitecture(genome, _battleData) {        // Mock optimization        return {            ...genome,            fitness: Math.min(1, genome.fitness + 0.1)        };    }    analyzeBattleEffectiveness(_battleResult) {        return {            redEffectiveness: Math.random(),            blueEffectiveness: Math.random(),            recommendations: ['optimize_speed', 'improve_accuracy']        };    }};// Mock TankAnalyst classglobal.TankAnalyst = class TankAnalyst {    constructor() {        this.analysisThreshold = 0.5;    }    analyzeBattlePatterns(_history) {        return {            patterns: ['flanking', 'defensive'],            confidence: Math.random()        };    }    identifyEmergentBehaviors(battleResult) {        // Mock emergent behavior detection        const behaviors = [];        if (battleResult.duration > 20) {            behaviors.push('Extended tactical engagement');        }        const redAccuracy = battleResult.redStats?.accuracy || 0.5;        const blueAccuracy = battleResult.blueStats?.accuracy || 0.4;        if (redAccuracy > 0.45 || blueAccuracy > 0.45) {            behaviors.push('High-precision targeting');        }        if (behaviors.includes('Extended tactical engagement')) {        }        if (behaviors.includes('High-precision targeting')) {        }        const redRatio = (battleResult.redStats?.damageDealt || 50) / Math.max(1, battleResult.redStats?.damageTaken || 40);        const blueRatio = (battleResult.blueStats?.damageDealt || 40) / Math.max(1, battleResult.blueStats?.damageTaken || 50);        if (redRatio > 1.3 || blueRatio > 1.3) {            behaviors.push('Superior tactical positioning');        } else {        }        const totalShots = (battleResult.redStats?.shotsFired || 0) + (battleResult.blueStats?.shotsFired || 0);        if (totalShots > 10) {            behaviors.push('Active engagement');        } else {        }        return behaviors;    }    predictCounterStrategies(_opponentGenomes, _history) {        return ['defensive', 'aggressive', 'adaptive'];    }};// Mock ASIArchModules for integrated ASI-ARCH functionalityglobal.ASIArchModules = class ASIArchModules {    constructor() {        this.researcher = new global.TankResearcher();        this.engineer = new global.TankEngineer();        this.analyst = new global.TankAnalyst();        this.cognitionModule = {            getTactics: () => ['aggressive', 'defensive', 'flanking', 'phalanx', 'scatter'],            applyCognition: (genome, _team) => {                const tactics = ['aggressive', 'defensive', 'flanking', 'phalanx', 'scatter'];                const tactic = tactics[Math.floor(Math.random() * tactics.length)];                return {                    ...genome,                    tactic: tactic,                    cognitiveScore: Math.random()                };            }        };    }    applyCognition(population, team) {        return population.map(individual => {            // Check if cognition module is available            if (this.cognitionModule) {                // Get a random tactic                const tactics = this.cognitionModule.getTactics();                const tactic = tactics[Math.floor(Math.random() * tactics.length)];                // Apply cognitive enhancement                return this.cognitionModule.applyCognition(individual, team);            }            return individual;        });    }    applyResearcher(population, team) {        // Researcher generates new experiments and genome variations        return population.map(individual => {            try {                // Apply research-based improvements to the genome                const improvedGenome = this.researcher.mutate(individual);                return {                    ...individual,                    ...improvedGenome,                    team: team                };            } catch (error) {                return { ...individual, team: team };            }        });    }    applyEngineer(population, team) {        // Engineer optimizes the architecture        return population.map(individual => {            try {                const optimized = this.engineer.optimizeArchitecture(individual, null);                return {                    ...individual,                    ...optimized,                    team: team                };            } catch (error) {                return { ...individual, team: team };            }        });    }    applyAnalyst(population, otherPopulation, team) {        // Analyst provides strategic insights and pattern analysis        return population.map(individual => {            try {                // Apply analyst insights to improve tactical behavior                return {                    ...individual,                    analyticalInsights: this.analyst.analyzeBattlePatterns([]),                    team: team                };            } catch (error) {                return { ...individual, team: team };            }        });    }    proposeExperiment(candidatePool, history, cognitionBase) {        return this.researcher.proposeExperiment(candidatePool, history, cognitionBase);    }    optimizeArchitecture(genome, battleData) {        return this.engineer.optimizeArchitecture(genome, battleData);    }    analyzeEmergentBehaviors(battleResult) {        return this.analyst.identifyEmergentBehaviors(battleResult);    }};// Mock TankAI class for tank creation in testsglobal.TankAI = class TankAI {    constructor(x, y, team, genome) {        this.x = x || 0;        this.y = y || 0;        this.team = team || 'red';        this.genome = genome || this.createDefaultGenome();        this.health = 100;        this.angle = 0;        this.speed = 2;        this.width = 30;        this.height = 30;        this.isDestroyed = false;        // Tank properties from genome        this.aggression = this.genome.genome[0] || 0.5;        this.accuracy = this.genome.genome[2] || 0.5;        this.speed = this.genome.genome[1] || 0.5;        this.defense = this.genome.genome[3] || 0.5;        this.teamwork = this.genome.genome[4] || 0.5;        this.adaptability = this.genome.genome[5] || 0.5;        this.learning = this.genome.genome[6] || 0.5;        this.riskTaking = this.genome.genome[7] || 0.5;        this.evasion = this.genome.genome[8] || 0.5;        // Behavioral properties        this.lastShot = 0;        this.shotsHit = 0;        this.shotsFired = 0;        this.damageDealt = 0;        this.damageTaken = 0;        this.enemyTanks = [];        this.teamTanks = [];    }    createDefaultGenome() {        return {            genome: [                0.5, // aggression                0.5, // speed                0.5, // accuracy                  0.5, // defense                0.5, // teamwork                0.5, // adaptability                0.5, // learning                0.5, // riskTaking                0.5  // evasion            ],            team: this.team,            fitness: 0.5,            battles: 0,            wins: 0,            isInitial: true        };    }    update(gameState, deltaTime) {        // Mock update logic        if (this.isDestroyed) {            return;        }        // Simple AI behavior based on genome        this.findTargets(gameState);        this.makeDecision(deltaTime);    }    findTargets(gameState) {        if (!gameState) {            return;        }        this.enemyTanks = (gameState.tanks || []).filter(tank =>             tank && tank.team !== this.team && !tank.isDestroyed        );        this.teamTanks = (gameState.tanks || []).filter(tank =>             tank && tank.team === this.team && tank !== this && !tank.isDestroyed        );    }    makeDecision(_deltaTime) {        // Simple decision making based on aggression and other traits        if (this.enemyTanks.length > 0 && this.aggression > 0.5) {            this.attackNearestEnemy();        } else if (this.defense > 0.6) {            this.seekCover();        }    }    attackNearestEnemy() {        if (this.enemyTanks.length === 0) {            return;        }        const target = this.enemyTanks[0]; // Mock: just pick first enemy        const dx = target.x - this.x;        const dy = target.y - this.y;        const distance = Math.sqrt(dx * dx + dy * dy);        if (distance < 200 && this.accuracy > Math.random()) {            this.fire(target);        }    }    seekCover() {        // Mock: simple movement away from enemies        if (this.enemyTanks.length > 0) {            const enemy = this.enemyTanks[0];            const dx = this.x - enemy.x;            const dy = this.y - enemy.y;            const distance = Math.sqrt(dx * dx + dy * dy);            if (distance > 0) {                this.x += (dx / distance) * this.speed * this.evasion;                this.y += (dy / distance) * this.speed * this.evasion;            }        }    }    fire(target) {        const now = Date.now();        if (now - this.lastShot < 1000) {            return; // Rate limit        }        this.lastShot = now;        this.shotsFired++;        // Mock hit detection based on accuracy        if (this.accuracy > Math.random() * 0.8) {            this.shotsHit++;            const damage = 25 + (this.aggression * 10);            this.damageDealt += damage;            if (target.takeDamage) {                target.takeDamage(damage);            }        }    }    takeDamage(amount) {        this.health -= amount;        this.damageTaken += amount;        if (this.health <= 0) {            this.isDestroyed = true;            this.health = 0;        }    }    getStats() {        return {            health: this.health,            accuracy: this.shotsFired > 0 ? this.shotsHit / this.shotsFired : 0,            shotsFired: this.shotsFired,            shotsHit: this.shotsHit,            damageDealt: this.damageDealt,            damageTaken: this.damageTaken,            isDestroyed: this.isDestroyed        };    }    render(ctx) {        // Mock render - just set fillStyle to indicate it was called        if (ctx && ctx.fillRect) {            ctx.fillStyle = this.team === 'red' ? '#ff0000' : '#0000ff';            ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);        }    }};