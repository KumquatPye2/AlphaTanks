// Final verification test for Blue vs Red genome update fix// Simulate the evolution candidate pool with realistic dataconst simulatedPool = [    {        genome: [0.8, 0.6, 0.7, 0.5, 0.9, 0.4, 0.6, 0.7, 0.5], // Red-oriented: high aggression        fitness: 0.75,        team: 'red',        battles: 5,        wins: 3,        generation: 1,        id: 'red_candidate_1'    },    {        genome: [0.4, 0.8, 0.9, 0.7, 0.6, 0.8, 0.5, 0.3, 0.7], // Blue-oriented: high teamwork/defense        fitness: 0.68,        team: 'blue',        battles: 5,        wins: 2,        generation: 1,        id: 'blue_candidate_1'    },    {        genome: [0.9, 0.5, 0.6, 0.4, 0.3, 0.7, 0.8, 0.9, 0.4], // Another red-like candidate        fitness: 0.82,        team: 'red',        battles: 6,        wins: 4,        generation: 1,        id: 'red_candidate_2'    }];simulatedPool.forEach(candidate => {    const g = candidate.genome;});// Simulate battle results that update fitness// Red team wins a battle - fitness should increasesimulatedPool[0].fitness = 0.85;  // Increase Red fitnesssimulatedPool[0].wins = 4;simulatedPool[0].battles = 6;// Blue team wins next battle - fitness should increase  simulatedPool[1].fitness = 0.78;  // Increase Blue fitnesssimulatedPool[1].wins = 3;simulatedPool[1].battles = 6;// Test team selection logic directlyfunction testTeamSelection(team, pool) {    // Filter by actual team assignment first (this should work)    let teamCandidates = pool.filter(c => c.team === team && c.battles > 0);    if (teamCandidates.length > 0) {        teamCandidates.sort((a, b) => (b.fitness || 0) - (a.fitness || 0));        const best = teamCandidates[0];        return best;    }    // Fallback to trait-based selection    const allCandidates = [...pool].sort((a, b) => (b.fitness || 0) - (a.fitness || 0));    for (const candidate of allCandidates) {        const genome = candidate.genome;        const aggression = genome[0] || 0;        const teamwork = genome[4] || 0;        const defense = genome[3] || 0;        if (team === 'red' && aggression > 0.3) {            return candidate;        } else if (team === 'blue' && (teamwork > 0.3 || defense > 0.3)) {            return candidate;        }    }    return null;}const redSelection = testTeamSelection('red', simulatedPool);const blueSelection = testTeamSelection('blue', simulatedPool);// Test the specific issue: cache invalidationfunction calculateChecksum(pool) {    return pool.reduce((sum, candidate, index) => {        const fitness = candidate.fitness || 0;        const battles = candidate.battles || 0;        const wins = candidate.wins || 0;        return sum + (fitness * 1000 + battles * 100 + wins * 10) * (index + 1);    }, 0);}const checksum1 = calculateChecksum(simulatedPool);// Simulate another battle resultsimulatedPool[2].fitness = 0.90;  // Update another candidatesimulatedPool[2].battles = 7;const checksum2 = calculateChecksum(simulatedPool);